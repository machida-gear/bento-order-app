# 設計上の重要な判断と理由

このドキュメントでは、お弁当注文 Web アプリケーションの設計において重要な判断と、その理由を記録します。

> 📖 **関連ドキュメント**: [README.md](./README.md) - すべてのドキュメントへの参照

---

## 自動注文の衝突時挙動

### 判断

**既存注文がある場合は自動注文をスキップする**

### 理由

- ユーザーが手動で注文した場合、その意図を尊重する必要がある
- 自動注文と手動注文の競合を避けることで、予期しない注文の上書きを防止
- ユーザーが「今日は別のメニューにしたい」と判断した場合に、自動注文がそれを上書きしないようにする

### 実装

- 自動注文実行時に、対象日の既存注文（`status = 'ordered'`）をチェック
- 既存注文がある場合は `skipped` として記録し、新規注文を作成しない

---

## 価格を注文時に確定する理由

### 判断

**注文確定時に `menu_price_id` を固定保存する**

### 理由

1. **価格改定への対応**: メニューの価格が改定されても、過去の注文の価格は変更されない
2. **集計の正確性**: 注文時の価格で集計することで、価格改定の影響を受けない正確な集計が可能
3. **監査性**: 注文時の価格が記録されるため、後から価格変更の履歴を追跡可能

### 実装

- `orders` テーブルに `menu_price_id` カラムを追加
- 注文確定時に `get_menu_price_id(menu_id, order_date)` で価格 ID を取得
- 取得した `menu_price_id` を `orders` テーブルに保存

---

## レポート画面での締日期間の自動計算

### 判断

**システム設定の締日を基準に締日期間を自動計算する**

### 理由

1. **運用の簡素化**: `closing_periods`テーブルへの手動登録が不要になり、運用が簡素化される
2. **一貫性**: システム設定の締日を基準にすることで、締日期間の計算が一貫性を持つ
3. **柔軟性**: システム設定の締日を変更すれば、自動的に新しい締日期間が計算される
4. **過去データの保持**: `closing_periods`テーブルは過去のデータとして保持し、必要に応じて参照可能

### 実装

- レポート画面でシステム設定の締日を取得
- 過去 12 ヶ月分の締日期間を自動計算
- 指定日締めの場合：開始日=前月の締日+1 日、終了日=当月の締日
- 月末締めの場合：開始日=当月 1 日、終了日=当月の最終日
- CSV 出力 API は `period_id` だけでなく `start_date` と `end_date` も受け取れる（後方互換性を維持）

---

## 締切判定を DB 時刻（JST）基準にしている理由

### 判断

**締切判定は DB 時刻（JST）を基準にする**

### 理由

1. **セキュリティ**: クライアント側の時刻は改ざん可能なため、DB 時刻を基準にする
2. **一貫性**: すべてのユーザーが同じ基準時刻で判定される
3. **タイムゾーン問題の回避**: JST 固定にすることで、タイムゾーンの違いによる問題を回避

### 実装

- `is_before_cutoff(order_date)` 関数内で `NOW() AT TIME ZONE 'UTC' AT TIME ZONE 'Asia/Tokyo'` を使用
- アプリ側の時刻は使用せず、DB 関数内で判定

---

## 注文の削除ではなくステータス変更にする理由

### 判断

**注文の削除は行わず、`status` を `canceled` に変更する**

### 理由

1. **監査性**: 削除された注文の履歴を保持することで、後から確認可能
2. **集計の正確性**: キャンセルされた注文も記録に残すことで、集計の正確性を保証
3. **データ整合性**: 外部キー制約により、削除が困難な場合がある

### 実装

- `orders` テーブルの `status` カラムで `'ordered'`、`'canceled'` を管理
- キャンセル時は `status = 'canceled'` に更新（削除はしない）
- 注文編集画面からキャンセル可能

---

## UNIQUE 制約で重複を防止する理由

### 判断

**`(user_id, menu_id, order_date, status)` の UNIQUE 制約で重複を防止**

### 理由

1. **データ整合性**: データベースレベルで重複を防止することで、アプリケーション側のバグによる重複を防ぐ
2. **パフォーマンス**: アプリケーション側で重複チェックを行う必要がなくなる
3. **明確性**: 制約により、どのような組み合わせが重複とみなされるかが明確

### 実装

- `orders` テーブルに `UNIQUE(user_id, menu_id, order_date, status)` 制約を追加
- `'ordered'` と `'canceled'` は別レコードとして存在可能（ステータスが異なるため）

---

## 価格履歴を期間管理する理由

### 判断

**`menu_prices` テーブルで `start_date` と `end_date` による期間管理を行う**

### 理由

1. **価格改定への対応**: 価格が改定された場合でも、過去の価格を保持できる
2. **集計の正確性**: 注文時の価格で集計することで、価格改定の影響を受けない
3. **履歴管理**: 価格の変更履歴を記録することで、後から価格の変遷を確認可能

### 実装

- `menu_prices` テーブルで `start_date`、`end_date` を管理
- `end_date` が `NULL` の場合は現在有効な価格
- `get_menu_price_id` 関数で重複期間を検証

---

## RLS を全テーブルで有効化する理由

### 判断

**すべてのテーブルで Row Level Security (RLS) を有効化する**

### 理由

1. **セキュリティ**: データベースレベルでアクセス制御を行うことで、アプリケーション側のバグによる情報漏洩を防ぐ
2. **最小権限の原則**: ユーザーが必要最小限のデータにのみアクセス可能にする
3. **監査性**: RLS ポリシーにより、誰がどのデータにアクセスできるかが明確

### 実装

- すべてのテーブルで `ALTER TABLE ... ENABLE ROW LEVEL SECURITY;` を実行
- 一般ユーザーと管理者で異なる RLS ポリシーを設定

---

## 自動注文の冪等性を保証する理由

### 判断

**自動注文実行時に二重実行を防止する仕組みを実装する**

### 理由

1. **データ整合性**: 同じ注文が複数回作成されることを防ぐ
2. **パフォーマンス**: 不要な処理を避けることで、パフォーマンスを向上
3. **予測可能性**: 自動注文の実行結果が予測可能になる

### 実装

- `auto_order_runs` テーブルに `UNIQUE(run_date, cutoff_time)` 制約を追加
- `auto_order_run_items` テーブルに `UNIQUE(run_id, user_id)` 制約を追加

---

## 注文可能日を order_calendar テーブルで管理する理由

### 判断

**注文可能日を `order_calendar` テーブルで日別に管理する**

### 理由

1. **柔軟性**: 日別に注文可能/不可を設定できるため、臨時の休業日にも対応可能
2. **明確性**: どの日が注文可能かがデータベースで明確に管理される
3. **拡張性**: 将来的に業者別の休業日管理（`vendor_holidays` テーブル）を追加する際の基盤となる

### 実装

- `order_calendar` テーブルで `target_date`、`is_available`、`deadline_time`、`note` を管理
- 現在は日別に設定（将来的に業者別の休業日管理を追加予定）

---

## 監査ログを JSONB で保存する理由

### 判断

**監査ログの詳細情報を `detail` カラム（JSONB 型）で保存する**

### 理由

1. **柔軟性**: 異なるアクション種別で異なる詳細情報を保存できる
2. **拡張性**: 新しいアクション種別を追加する際に、スキーマ変更が不要
3. **検索性**: JSONB 型により、詳細情報の検索が可能

### 実装

- `audit_logs` テーブルの `detail` カラムを JSONB 型に設定
- アクション種別ごとに異なる JSON 構造を保存可能

---

## システム設定を別テーブルで管理する理由

### 判断

**システム設定を`system_settings`テーブルで管理する（シングルトンパターン）**

### 理由

1. **設定の一元管理**: システム全体の設定を 1 つのテーブルで管理することで、設定の変更が容易になる
2. **拡張性**: 新しい設定項目を追加する際に、テーブル構造を変更せずに JSONB カラムに追加できる
3. **パフォーマンス**: 設定は頻繁に変更されないため、シングルトンパターンで十分
4. **一貫性**: すべての設定が同じ場所に集約されることで、設定の確認と変更が容易になる

### 実装

- `system_settings`テーブルを作成（id=1 のみ存在）
- `default_deadline_time`、`closing_day`、`day_of_week_settings`を管理
- RLS ポリシー: 全ユーザーが参照可能、管理者のみ更新可能

---

## 退職日の処理ロジック

### 判断

**退職日が未来の場合は在籍中として扱い、過去の場合は退職済みとして扱う**

### 理由

1. **実用性**: 未来の退職日を設定した場合でも、その日まではシステムを利用可能にする必要がある
2. **自動無効化**: 退職日の翌日から自動的に無効化することで、手動での操作を不要にする
3. **データ整合性**: 退職日と`is_active`の状態を整合性が取れた状態で管理する

### 実装

- ユーザー管理 API で、退職日が過去の日付の場合は`is_active = false`に自動設定
- 退職日の自動無効化 Cron Job で、毎日午前 0 時（JST）に退職日が過去のユーザーを無効化
- 注文 API で、`is_active = false`または退職日が過去のユーザーは注文不可

---

## パスワードリセット機能の実装方針

### 判断

**管理者画面とログインページの両方からパスワードリセットを可能にする**

### 理由

1. **利便性**: ユーザーが自分でパスワードをリセットできるようにする
2. **管理者のサポート**: 管理者がユーザーのパスワードをリセットできるようにする
3. **セキュリティ**: Supabase Auth の標準機能を使用することで、セキュリティを確保

### 実装

- 管理者画面から：管理者がユーザーのパスワードリセットメールを送信
- ログインページから：ユーザーが自分のメールアドレスを入力してパスワードリセットメールを送信
- Supabase Admin API の`generateLink`を使用してパスワードリセットリンクを生成

---

## デフォルト締切時刻変更時の自動更新

### 判断

**デフォルト締切時刻を変更した場合、今日以降の日付で既に締切時刻が設定されているレコードも自動更新する**

### 理由

1. **一貫性**: システム全体で締切時刻を統一するため
2. **利便性**: 手動での個別更新を不要にする
3. **過去データの保護**: 過去の日付は更新しないことで、過去の設定を保護

### 実装

- システム設定更新時に、`order_calendar`テーブルの今日以降で`deadline_time`が NULL でないレコードを自動更新
- 時刻形式の統一処理を実装（DB は`HH:MM:SS`形式、リクエストは`HH:MM`形式）

---

## レポート画面での締日期間の自動計算

### 判断

**システム設定の締日を基準に締日期間を自動計算する**

### 理由

1. **運用の簡素化**: `closing_periods`テーブルへの手動登録が不要になり、運用が簡素化される
2. **一貫性**: システム設定の締日を基準にすることで、締日期間の計算が一貫性を持つ
3. **柔軟性**: システム設定の締日を変更すれば、自動的に新しい締日期間が計算される
4. **過去データの保持**: `closing_periods`テーブルは過去のデータとして保持し、必要に応じて参照可能

### 実装

- レポート画面でシステム設定の締日を取得
- 過去 12 ヶ月分の締日期間を自動計算
- 指定日締めの場合：開始日=前月の締日+1 日、終了日=当月の締日
- 月末締めの場合：開始日=当月 1 日、終了日=当月の最終日

---

## 未来の価格改定設定機能

### 判断

**新規価格登録時に、既存の有効な価格の`end_date`を自動設定する**

### 理由

1. **運用の簡素化**: 価格改定を事前に設定する際、既存の価格を手動で終了する必要がなくなる
2. **データ整合性**: 価格期間の重複を自動的に防止し、データ整合性を保証
3. **ユーザビリティ**: 未来の価格改定を簡単に設定できるようになる

### 実装

- 新規価格登録時に、既存の有効な価格（`end_date`が NULL）を確認
- 新しい価格の`start_date`が未来の日付で、既存の価格の`start_date`より後の場合
- 既存の価格の`end_date`を新しい価格の`start_date`の前日に自動設定

---

## レポート画面での代理注文の視覚表示

### 判断

**管理者が代理で注文した注文は、視覚的に識別できるように表示する**

### 理由

1. **透明性**: 誰が注文したか、管理者が代理で注文したかを明確にする
2. **監査性**: 代理注文を視覚的に識別することで、監査が容易になる
3. **ユーザビリティ**: 代理注文であることが一目でわかるようにする

### 実装

- 監査ログから代理注文を識別（`action`に`.admin`が含まれる場合）
- 背景色を薄いオレンジに変更
- 左側にオレンジのボーダーを追加
- 注文日の横に「代理」バッジを表示

---

## PDF出力機能の実装方針

### 判断

**業者ごとの注文書をPDFで生成し、メールやFAXで送信できるようにする**

### 理由

1. **運用効率**: 業者への注文書送付を効率化する
2. **正確性**: 注文明細を正確に伝える
3. **記録性**: PDFとして記録を残すことができる

### 実装

- `pdfkit`を使用してPDF生成（Next.jsのAPI Routeで動作しやすい）
- A4サイズでPDFを生成
- 業者ごとの注文書のみ（全業者のPDFは不要）
- 注文明細をテーブル形式で表示

---

## 新規登録制限機能の実装方針

### 判断

**招待コードと社員コードマスターの併用による二重チェックで新規登録を制限する**

### 理由

1. **セキュリティ**: 誰でも自由にユーザー登録できないようにする
2. **社員限定**: 社員のみが登録できるようにする
3. **二重チェック**: 招待コードと社員コードマスターの両方をチェックすることで、より堅牢なセキュリティを実現
4. **追跡可能性**: 社員コードマスターで登録済みの社員コードを管理することで、誰が登録したかを追跡可能

### 実装

- `employee_codes`テーブルで社員コードマスターを管理（`employee_code`、`full_name`、`is_registered`、`registered_user_id`）
- `system_settings`テーブルに`invitation_code`、`invitation_code_max_uses`、`invitation_code_used_count`を追加
- 新規登録時に以下のチェックを実行：
  1. 招待コードが正しいか（`system_settings.invitation_code`と一致）
  2. 招待コードの使用回数が上限に達していないか（`invitation_code_used_count < invitation_code_max_uses`）
  3. 社員コードがマスターに存在するか（`employee_codes.employee_code`と一致）
  4. 社員コードが未登録か（`employee_codes.is_registered = false`）
- 登録成功時に`employee_codes.is_registered = true`、`registered_user_id`を更新
- 登録成功時に`invitation_code_used_count`をインクリメント

---

## 招待コード管理の専用ページ化

### 判断

**招待コードの管理を専用ページに分離する**

### 理由

1. **ユーザビリティ**: 招待コードの設定が専用ページになることで、設定が容易になる
2. **関心の分離**: システム設定と招待コード設定を分離することで、管理画面の構造が明確になる
3. **拡張性**: 将来的に招待コードに関連する機能（複数の招待コード、有効期限など）を追加する際に、専用ページの方が拡張しやすい
4. **エラー回避**: システム設定と混在することで起こるエラーを回避

### 実装

- `/admin/invitation-code`ページを新規作成
- 招待コードの自動生成機能（4桁の数字）
- 最大使用回数の設定（制限あり/無制限）
- 現在の使用回数の表示
- APIエンドポイント`/api/admin/invitation-code`を新規作成（GET、PUT）
- 招待コード変更時に`invitation_code_used_count`を自動的に0にリセット

---

## 社員コード変更機能の実装方針

### 判断

**管理者がユーザーの社員コードを変更可能にし、変更時に古い社員コードを解放して再利用可能にする**

### 理由

1. **誤登録への対応**: 登録時に間違えて社員コードを入力してしまった場合、修正できるようにする
2. **社員コードの再利用**: 誤って使用した社員コードを将来使えるようにする
3. **データ整合性**: 注文データは`user_id`で参照しているため、社員コードを変更しても整合性は保たれる

### 実装

- 社員コード変更時に、古い社員コードを`employee_codes`テーブルで解放（`is_registered = false`、`registered_user_id = NULL`）
- 新しい社員コードを`employee_codes`テーブルでチェック（未登録のみ許可）
- 監査ログに変更前後の社員コードを記録

### 注意事項

- CSV/PDF出力では、その時点の`profiles`テーブルの社員コードが表示される（過去の注文でも現在の社員コードが表示される）
- 監査ログには変更前後の社員コードが記録されるため、履歴として問題ない

---

## 新規登録方式の変更（承認方式への移行）

### 判断

**社員コードマスター方式を廃止し、新規登録時は承認待ちにして、管理者が承認する方式に変更する**

### 理由

1. **運用の簡素化**: 社員コードマスターへの事前登録が不要になり、運用が簡素化される
2. **柔軟性**: 管理者が新規登録されたユーザーの情報を確認してから承認できる
3. **セキュリティ**: 承認待ちユーザーはシステムを利用できないため、不正な登録を防止できる

### 実装

- 新規登録時は`is_active = false`（承認待ち）に設定
- 管理者が承認すると`is_active = true`にする
- 新規登録時に監査ログに記録（`user.signup.pending`アクション）
- ログイン時に承認待ちユーザーを検出し、適切なメッセージを表示

### 変更内容

- 社員コードマスター方式のチェックを削除
- 新規登録時は`is_active = false`に設定
- 管理者が承認待ちユーザー一覧から承認・削除（拒否）できる

---

## 承認待ちユーザーの削除（拒否）機能

### 判断

**承認待ちユーザーを承認せずに削除（拒否）できる機能を実装する**

### 理由

1. **運用の柔軟性**: 誤登録や不正な登録を承認せずに削除できる
2. **データ整合性**: 削除前に、関連する注文、自動注文設定、自動注文テンプレートを削除することで、外部キー制約違反を回避
3. **社員コードの解放**: 削除時に`employee_codes`テーブルで社員コードを解放し、再利用可能にする

### 実装

- 承認待ちユーザー削除API（`POST /api/admin/users/[id]/reject`）を実装
- 削除前に、関連する注文、自動注文設定、自動注文テンプレートを削除
- `employee_codes`テーブルで社員コードを解放
- Supabase Authのユーザーを削除
- `profiles`テーブルのレコードを削除
- 監査ログに記録（`user.reject`アクション）

---

## ユーザー削除時の承認待ちリスト除外

### 判断

**ユーザー削除時に`left_date`を今日の日付に設定し、承認待ちリストから除外する。承認待ちAPIの条件は`left_date >= 明日`とする。**

### 理由

1. **明確な分類**: 削除されたユーザーと承認待ちユーザーを明確に区別する
2. **リストの正確性**: 承認待ちリストに不要なユーザーが蓄積しないようにする
3. **即時反映**: 削除直後から正しい状態が表示されるようにする
4. **運用の簡素化**: 管理者が承認待ちユーザーを正確に把握できるようにする

### 実装

- 削除APIで`is_active = false`と`left_date = 今日の日付`を同時に設定
- 承認待ちAPIの条件を`left_date >= 明日`に変更（今日の日付を除外）
- フロントエンドで削除後に`fetchPendingUsers()`も呼び出す

### 承認待ちユーザーの定義

- **承認待ち**: `is_active = false` かつ `left_date`が未設定または未来の日付（明日以降）
- **無効なユーザー**: `is_active = false` かつ `left_date`が過去または今日の日付

---

## Vercel Cron Jobs制限への対応：Cron Jobsの統合

### 判断

**VercelのCron Jobs制限を回避するため、2つのCron Jobsを1つに統合する**

### 理由

1. **プラン制限の回避**: Vercelの無料プランでは、チームあたり最大2つのCron Jobsしか作成できない。既に他のプロジェクトで2つ使用している場合、このプロジェクトで2つ作成しようとすると制限に達する
2. **運用の簡素化**: 1つのCron Jobで複数の処理を実行することで、管理が簡素化される
3. **コスト削減**: プランアップグレードの必要性を回避できる
4. **実用性**: 退職済みユーザー無効化の実行タイミング（毎日0:00 JST → 毎日10:00 JST）の変更は、実用上問題ない

### 実装

- 退職済みユーザー無効化処理を自動注文実行API（`/api/auto-order/run`）内で実行
- 自動注文実行の前に退職済みユーザーを無効化
- エラーが発生しても自動注文処理は続行（ログに記録）
- `vercel.json`から退職済みユーザー無効化のCron Job設定を削除
- `/api/admin/users/deactivate-expired`APIは残しており、手動実行やテストで使用可能

### 注意事項

- 退職済みユーザー無効化の実行タイミングが変更される（毎日0:00 JST → 毎日10:00 JST）
- 実用上は問題ないが、より早いタイミングで無効化したい場合は、プランアップグレードを検討する

---

## Transaction connection (6543)の使用方針

### 判断

**パフォーマンスが重要なクエリやトランザクションが必要な処理で、Transaction connection (6543)を使用する**

### 理由

1. **パフォーマンス向上**: 接続プールを活用し、複数のクエリを同じ接続で実行することで、接続確立のオーバーヘッドを削減
2. **トランザクション保証**: 注文作成・更新・キャンセル処理をトランザクション内で実行することで、データ整合性を確保
3. **JOINクエリの最適化**: SQL JOINを使用して、Supabaseのネストしたクエリと同等のデータを効率的に取得
4. **段階的な移行**: 既存のSupabaseクライアントと併用可能で、段階的に移行できる

### 実装

- 注文カレンダー、新規注文、注文変更、注文履歴画面でTransaction connectionを使用
- 注文作成・更新・キャンセル処理は`transaction`関数を使用してトランザクション保証
- データ取得処理は`queryDatabase`関数を使用してパフォーマンス向上
- 既存のSupabaseクライアント（`supabaseAdmin`）と併用可能

### 注意事項

- RLSは直接PostgreSQL接続では自動適用されないため、適切な権限チェックを実装
- `DATABASE_URL`環境変数がTransaction connection (6543)を使用していることを確認

---

## まとめ

これらの判断は、以下の原則に基づいています：

1. **データ整合性**: データベースレベルで整合性を保証
2. **セキュリティ**: 最小権限の原則と RLS によるアクセス制御
3. **監査性**: すべての重要な操作を記録
4. **柔軟性**: 将来的な変更に対応できる設計
5. **予測可能性**: システムの動作が予測可能で一貫性がある
6. **保守性**: 設定の一元管理により、保守が容易になる
7. **ユーザビリティ**: ユーザーが使いやすい機能を提供
8. **運用の簡素化**: 手動操作を減らし、自動化により運用を簡素化
9. **セキュリティ強化**: 承認方式により、不正な登録を防止
10. **誤登録への対応**: 社員コードの変更と再利用により、誤登録に対応
11. **明確な分類**: ユーザーの状態を明確に分類し、適切なリストに表示する
12. **パフォーマンス最適化**: Transaction connectionを使用して、パフォーマンスを向上