# カレンダーページ13日セル表示問題修正

## 問題

- 本日は1月9日で、まだ締切日時がきていない12日、14日の注文は注文変更ができる
- しかし、13日は注文変更ができない（グレーアウトして変更可が非表示）
- ローカル環境では正しく表示されているが、本番環境では表示されない
- React error #418（Hydration Mismatch）が再発

## 原因

### 1. 13日のセルがグレーアウトされる問題の原因

1. **本番環境とローカル環境での型の違い**:
   - 本番環境では`order.order_date`がDateオブジェクトとして取得されていた
   - ローカル環境では`order.order_date`が文字列として取得されていた
   - これにより、本番環境でのみ問題が発生していた

2. **`orderDateStr`の計算エラー**:
   - `order.order_date`がDateオブジェクトの場合、`String(order.order_date)`が`"Tue Jan 13 2026 09:00:00 GMT+0900 (日本標準時)"`のような形式になる
   - `split('T')[0].split(' ')[0]`を実行すると、`"Tue"`になる
   - その結果、`orderDateStr`が`"Tue"`になり、`todayStr`（`"2026-01-09"`）と比較して`"Tue" < "2026-01-09"`が`true`になり、`canEditOrderValue`が`false`になっていた

3. **TypeScriptの型定義との不一致**:
   - データベースの型定義では`order.order_date`が`string`として定義されている
   - しかし、実行時にはDateオブジェクトになる可能性がある
   - `instanceof Date`チェックがTypeScriptの型チェックでエラーになる

### 2. React error #418の再発の原因

1. **`useState`の初期値で`localStorage`にアクセス**:
   - `useState`の初期値として`getInitialToday()`と`getInitialNow()`を呼び出していた
   - これらの関数は`localStorage`にアクセスするため、サーバー側（`localStorage`が存在しない）とクライアント側（`localStorage`から値を取得できる）で異なる初期値を返していた
   - これにより、サーバー側とクライアント側で生成されるHTMLが異なり、hydration mismatchが発生していた

## 解決策

### 1. 13日のセルがグレーアウトされる問題の解決策

#### 1.1 `order.order_date`がDateオブジェクトの場合の処理

- `order.order_date`がDateオブジェクトの場合、`getFullYear()`、`getMonth()`、`getDate()`を使用して`YYYY-MM-DD`形式に変換
- 文字列の場合は既存の処理を維持（`split('T')[0].split(' ')[0]`）
- その他の場合は一度Dateオブジェクトに変換してから`YYYY-MM-DD`形式に変換

**修正前:**
```typescript
const orderDateStr = typeof order.order_date === 'string' 
  ? order.order_date.split('T')[0].split(' ')[0]
  : String(order.order_date).split('T')[0].split(' ')[0];
```

**修正後:**
```typescript
let orderDateStr: string;
const orderDateValue = order.order_date as string | Date;
if (orderDateValue instanceof Date) {
  // Dateオブジェクトの場合、YYYY-MM-DD形式に変換
  orderDateStr = `${orderDateValue.getFullYear()}-${String(orderDateValue.getMonth() + 1).padStart(2, "0")}-${String(orderDateValue.getDate()).padStart(2, "0")}`;
} else if (typeof orderDateValue === 'string') {
  // 文字列の場合、YYYY-MM-DD形式を抽出
  orderDateStr = orderDateValue.split('T')[0].split(' ')[0];
} else {
  // その他の場合、一度Dateオブジェクトに変換してからYYYY-MM-DD形式に変換
  const orderDate = new Date(orderDateValue);
  orderDateStr = `${orderDate.getFullYear()}-${String(orderDate.getMonth() + 1).padStart(2, "0")}-${String(orderDate.getDate()).padStart(2, "0")}`;
}
```

#### 1.2 TypeScriptの型エラーの修正

- 型アサーションを使用して`order.order_date`を`string | Date`として扱う
- これにより、`instanceof Date`チェックが可能になる

**修正:**
```typescript
const orderDateValue = order.order_date as string | Date;
if (orderDateValue instanceof Date) {
  // ...
}
```

### 2. React error #418の再発の解決策

#### 2.1 `useState`の初期値を`null`に統一

- `useState`の初期値を`null`に統一することで、サーバー側とクライアント側で同じ初期HTMLを生成
- `localStorage`からの復元は`useEffect`内でのみ実行

**修正前:**
```typescript
const initialToday = getInitialToday();
const initialNow = getInitialNow();

const [today, setToday] = useState<Date | null>(initialToday);
const [now, setNow] = useState<Date | null>(initialNow);
const [isMounted, setIsMounted] = useState(!!(initialToday && initialNow));
```

**修正後:**
```typescript
// サーバー側とクライアント側で同じ初期値を返す（hydration mismatchを防ぐ）
// localStorageからの復元はuseEffectで行う
const [today, setToday] = useState<Date | null>(null);
const [now, setNow] = useState<Date | null>(null);
const [isMounted, setIsMounted] = useState(false);
```

## 修正ファイル

### `components/calendar-grid.tsx`

1. **`order.order_date`がDateオブジェクトの場合の処理を追加**:
   - `order.order_date`がDateオブジェクトの場合、`YYYY-MM-DD`形式に変換する処理を追加
   - 型アサーションを使用して`instanceof Date`チェックを可能に

2. **`useState`の初期値を`null`に統一**:
   - `getInitialToday()`と`getInitialNow()`の呼び出しを削除
   - `useState`の初期値を`null`に統一
   - `localStorage`からの復元は`useEffect`内でのみ実行

## 確認事項

- ✅ 13日のセルが正しく表示される（`orderDateStr`が`"2026-01-13"`になり、`canEditOrderValue`が`true`になる）
- ✅ 12日、13日、14日の注文が正しく変更可能になる
- ✅ React error #418が解消される
- ✅ 本番環境とローカル環境で同じ動作になる

## 注意事項

### 環境による型の違い

- **本番環境とローカル環境の違い**: 本番環境とローカル環境で`order.order_date`の型が異なる可能性があるため、両方のケースに対応する必要があります
- **型アサーションの使用**: TypeScriptの型定義では`order.order_date`が`string`として定義されているため、実行時にDateオブジェクトになる可能性がある場合は、型アサーションを使用する必要があります

### Hydration Mismatchの防止

- **`useState`の初期値**: `useState`の初期値でブラウザAPI（`localStorage`など）にアクセスしないようにすることで、サーバー側とクライアント側で同じ初期HTMLを生成できます
- **`useEffect`での復元**: ブラウザAPIへのアクセスは`useEffect`内でのみ実行することで、hydration mismatchを防止できます

### デバッグログ

- デバッグログ内でも型アサーションを使用する必要があります
- `orderDateStr calculation`ログで、`orderDateStr`が正しく`YYYY-MM-DD`形式になっているか確認できます

---

**関連ドキュメント**:
- [CHANGELOG.md](./CHANGELOG.md) - 変更履歴
- [PROGRESS.md](./PROGRESS.md) - 進捗状況
- [カレンダーページHydration Mismatchエラー修正.md](./カレンダーページHydration Mismatchエラー修正.md) - 関連する修正
- [カレンダーページ過去注文・ちらつき問題修正.md](./カレンダーページ過去注文・ちらつき問題修正.md) - 関連する修正