# 設計上の重要な判断と理由

このドキュメントでは、お弁当注文 Web アプリケーションの設計において重要な判断と、その理由を記録します。

> 📖 **関連ドキュメント**: [README.md](./README.md) - すべてのドキュメントへの参照

---

## 自動注文の衝突時挙動

### 判断

**既存注文がある場合は自動注文をスキップする**

### 理由

- ユーザーが手動で注文した場合、その意図を尊重する必要がある
- 自動注文と手動注文の競合を避けることで、予期しない注文の上書きを防止
- ユーザーが「今日は別のメニューにしたい」と判断した場合に、自動注文がそれを上書きしないようにする

### 実装

- 自動注文実行時に、対象日の既存注文（`status = 'ordered'`）をチェック
- 既存注文がある場合は `skipped` として記録し、新規注文を作成しない

---

## 価格を注文時に確定する理由

### 判断

**注文確定時に `menu_price_id` を固定保存する**

### 理由

1. **価格改定への対応**: メニューの価格が改定されても、過去の注文の価格は変更されない
2. **集計の正確性**: 注文時の価格で集計することで、価格改定の影響を受けない正確な集計が可能
3. **監査性**: 注文時の価格が記録されるため、後から価格変更の履歴を追跡可能

### 実装

- `orders` テーブルに `menu_price_id` カラムを追加
- 注文確定時に `get_menu_price_id(menu_id, order_date)` で価格 ID を取得
- 取得した `menu_price_id` を `orders` テーブルに保存

---

## 締日変更時に closing_periods を基準にする理由

### 判断

**集計期間の判定に `closing_periods` テーブルを使用する**

### 理由

1. **柔軟性**: 締日が月次で固定されていない場合（例: 月末が土曜日の場合は前日が締日）に対応可能
2. **履歴管理**: 過去の締日期間を記録することで、後から集計期間を確認可能
3. **変更対応**: 締日の変更が発生した場合でも、過去の集計期間を正確に再現可能

### 実装

- `closing_periods` テーブルで `start_date`、`end_date`、`closing_date` を管理
- CSV 出力時は `closing_periods` を基準に集計期間を決定

---

## 締切判定を DB 時刻（JST）基準にしている理由

### 判断

**締切判定は DB 時刻（JST）を基準にする**

### 理由

1. **セキュリティ**: クライアント側の時刻は改ざん可能なため、DB 時刻を基準にする
2. **一貫性**: すべてのユーザーが同じ基準時刻で判定される
3. **タイムゾーン問題の回避**: JST 固定にすることで、タイムゾーンの違いによる問題を回避

### 実装

- `is_before_cutoff(order_date)` 関数内で `NOW() AT TIME ZONE 'UTC' AT TIME ZONE 'Asia/Tokyo'` を使用
- アプリ側の時刻は使用せず、DB 関数内で判定

---

## 注文の削除ではなくステータス変更にする理由

### 判断

**注文の削除は行わず、`status` を `canceled` に変更する**

### 理由

1. **監査性**: 削除された注文の履歴を保持することで、後から確認可能
2. **集計の正確性**: キャンセルされた注文も記録に残すことで、集計の正確性を保証
3. **データ整合性**: 外部キー制約により、削除が困難な場合がある

### 実装

- `orders` テーブルの `status` カラムで `'ordered'`、`'canceled'` を管理
- キャンセル時は `status = 'canceled'` に更新（削除はしない）
- 注文編集画面からキャンセル可能

---

## UNIQUE 制約で重複を防止する理由

### 判断

**`(user_id, menu_id, order_date, status)` の UNIQUE 制約で重複を防止**

### 理由

1. **データ整合性**: データベースレベルで重複を防止することで、アプリケーション側のバグによる重複を防ぐ
2. **パフォーマンス**: アプリケーション側で重複チェックを行う必要がなくなる
3. **明確性**: 制約により、どのような組み合わせが重複とみなされるかが明確

### 実装

- `orders` テーブルに `UNIQUE(user_id, menu_id, order_date, status)` 制約を追加
- `'ordered'` と `'canceled'` は別レコードとして存在可能（ステータスが異なるため）

---

## 価格履歴を期間管理する理由

### 判断

**`menu_prices` テーブルで `start_date` と `end_date` による期間管理を行う**

### 理由

1. **価格改定への対応**: 価格が改定された場合でも、過去の価格を保持できる
2. **集計の正確性**: 注文時の価格で集計することで、価格改定の影響を受けない
3. **履歴管理**: 価格の変更履歴を記録することで、後から価格の変遷を確認可能

### 実装

- `menu_prices` テーブルで `start_date`、`end_date` を管理
- `end_date` が `NULL` の場合は現在有効な価格
- `get_menu_price_id` 関数で重複期間を検証

---

## RLS を全テーブルで有効化する理由

### 判断

**すべてのテーブルで Row Level Security (RLS) を有効化する**

### 理由

1. **セキュリティ**: データベースレベルでアクセス制御を行うことで、アプリケーション側のバグによる情報漏洩を防ぐ
2. **最小権限の原則**: ユーザーが必要最小限のデータにのみアクセス可能にする
3. **監査性**: RLS ポリシーにより、誰がどのデータにアクセスできるかが明確

### 実装

- すべてのテーブルで `ALTER TABLE ... ENABLE ROW LEVEL SECURITY;` を実行
- 一般ユーザーと管理者で異なる RLS ポリシーを設定

---

## 自動注文の冪等性を保証する理由

### 判断

**自動注文実行時に二重実行を防止する仕組みを実装する**

### 理由

1. **データ整合性**: 同じ注文が複数回作成されることを防ぐ
2. **パフォーマンス**: 不要な処理を避けることで、パフォーマンスを向上
3. **予測可能性**: 自動注文の実行結果が予測可能になる

### 実装

- `auto_order_runs` テーブルに `UNIQUE(run_date, cutoff_time)` 制約を追加
- `auto_order_run_items` テーブルに `UNIQUE(run_id, user_id)` 制約を追加

---

## 注文可能日を order_calendar テーブルで管理する理由

### 判断

**注文可能日を `order_calendar` テーブルで日別に管理する**

### 理由

1. **柔軟性**: 日別に注文可能/不可を設定できるため、臨時の休業日にも対応可能
2. **明確性**: どの日が注文可能かがデータベースで明確に管理される
3. **拡張性**: 将来的に業者別の休業日管理（`vendor_holidays` テーブル）を追加する際の基盤となる

### 実装

- `order_calendar` テーブルで `target_date`、`is_available`、`deadline_time`、`note` を管理
- 現在は日別に設定（将来的に業者別の休業日管理を追加予定）

---

## 監査ログを JSONB で保存する理由

### 判断

**監査ログの詳細情報を `detail` カラム（JSONB 型）で保存する**

### 理由

1. **柔軟性**: 異なるアクション種別で異なる詳細情報を保存できる
2. **拡張性**: 新しいアクション種別を追加する際に、スキーマ変更が不要
3. **検索性**: JSONB 型により、詳細情報の検索が可能

### 実装

- `audit_logs` テーブルの `detail` カラムを JSONB 型に設定
- アクション種別ごとに異なる JSON 構造を保存可能

---

## システム設定を別テーブルで管理する理由

### 判断

**システム設定を`system_settings`テーブルで管理する（シングルトンパターン）**

### 理由

1. **設定の一元管理**: システム全体の設定を 1 つのテーブルで管理することで、設定の変更が容易になる
2. **拡張性**: 新しい設定項目を追加する際に、テーブル構造を変更せずに JSONB カラムに追加できる
3. **パフォーマンス**: 設定は頻繁に変更されないため、シングルトンパターンで十分
4. **一貫性**: すべての設定が同じ場所に集約されることで、設定の確認と変更が容易になる

### 実装

- `system_settings`テーブルを作成（id=1 のみ存在）
- `default_deadline_time`、`closing_day`、`day_of_week_settings`を管理
- RLS ポリシー: 全ユーザーが参照可能、管理者のみ更新可能

---

## 管理者による注文代理操作機能

### 判断

**管理者が任意のユーザーのカレンダー画面を開いて、そのユーザーとして注文操作ができるようにする**

### 理由

1. **運用の柔軟性**: ユーザーが不在の場合や操作に不慣れな場合、管理者が代理で注文できるようにする
2. **ユーザビリティ**: ユーザー本人と同じ画面で操作できるため、直感的で分かりやすい
3. **セキュリティ**: 管理者のみがアクセス可能な機能として実装し、適切な権限管理を行う

### 実装

- カレンダー画面で`user_id`パラメータを指定することで、管理者が任意のユーザーのカレンダーを開く
- 注文作成・編集・キャンセル API で、管理者が`user_id`パラメータを指定して代理操作が可能
- 監査ログに管理者による操作であることを記録
- ユーザー管理画面からカレンダー画面へのアクセスボタンを提供

---

## 価格編集時の上書き許可と自動調整

### 判断

**価格編集時は重複チェックを削除し、上書きを許可する。また、編集時に開始日を変更した場合、重複する既存価格の終了日を自動調整する。**

### 理由

1. **運用の柔軟性**: 価格設定を柔軟に変更できるようにする
2. **データ整合性**: 編集時に重複する既存価格の終了日を自動調整することで、期間の重複を防止
3. **ユーザビリティ**: 管理者が価格設定を簡単に修正できるようにする

### 実装

- 価格編集 API で重複チェックを削除
- 編集時に、新しい開始日と期間が重複する既存価格の`end_date`を新しい開始日の前日に自動設定
- 新規作成時の自動調整機能と同様のロジックを編集時にも適用

---

## 価格管理画面の表示改善

### 判断

**価格一覧を業者別にグループ化し、業者名のみを表示する**

### 理由

1. **可読性**: 業者ごとにグループ化することで、価格設定を管理しやすくする
2. **ユーザビリティ**: 業者名のみを表示することで、分かりやすくする
3. **運用効率**: 業者ごとに価格設定を確認・管理しやすくなる

### 実装

- 価格データを業者別にグループ化し、その中でメニュー別にグループ化
- 業者コードではなく業者名のみを表示
- メニュー選択ドロップダウンでも業者名を表示

---

## パスワードリセット機能の一元化

### 判断

**パスワードリセット機能はログインページからのみ提供する**

### 理由

1. **ユーザビリティ**: ユーザーがパスワードを忘れた場合、ログインページから直接リセットできる方が直感的
2. **機能の重複回避**: 管理者画面とログインページの両方にパスワードリセット機能があると、機能が重複し、保守が複雑になる
3. **セキュリティ**: ログインページからのパスワードリセットは、Supabase Auth の標準機能を使用しており、セキュリティが確保されている

### 実装

- 管理者画面からのパスワードリセット機能を削除
- ログインページ（`app/(auth)/login/page.tsx`）のパスワードリセット機能のみを維持

---

## キャンセル済み注文の再注文時の処理

### 判断

**キャンセル済み注文がある場合、同じ`menu_id`で新規注文を作成する際は、キャンセル済み注文を自動削除する**

### 理由

1. **UNIQUE 制約の回避**: UNIQUE 制約は`(user_id, menu_id, order_date, status)`のため、同じ`menu_id`でキャンセル済みの注文がある場合、新規注文作成時に UNIQUE 制約違反が発生する可能性がある
2. **ユーザビリティ**: キャンセル後に同じメニューで再度注文できるようにする
3. **データ整合性**: キャンセル済みの注文は既に無効なため、削除しても問題ない

### 実装

- 注文作成 API で、同じ`menu_id`でキャンセル済み（`status = 'canceled'`）の注文がある場合、自動的に削除してから新規注文を作成

---

## 締切時間を過ぎた注文のキャンセルボタン非表示

### 判断

**締切時間を過ぎた注文のキャンセルボタンは非表示にし、キャンセル処理中に締切時間を過ぎた場合はエラーメッセージを表示する**

### 理由

1. **ユーザビリティ**: 締切時間を過ぎた注文にキャンセルボタンが表示されていると、ユーザーが押してエラーが発生する可能性がある
2. **エラーメッセージの明確化**: キャンセル処理中に締切時間を過ぎた場合、エラーメッセージを明確に表示することで、ユーザーが状況を理解しやすくなる
3. **一貫性**: 注文編集画面でも締切時間を過ぎた注文は変更不可であるため、注文履歴画面でも同様の動作にする

### 実装

- 注文履歴画面でカレンダー情報を取得して締切時間をチェック
- 締切時間を過ぎた注文のキャンセルボタンを非表示
- キャンセル API で締切時間を再チェックし、過ぎている場合はエラーメッセージを返す

---

## ユーザー削除時の注文データ保護

### 判断

**既存ユーザーの削除は論理削除のみとし、注文データを保持する。外部キー制約により物理削除を防止する。**

### 理由

1. **会計・集計の正確性**: 注文データは会計・集計に必要なため、削除してはいけない
2. **監査性**: 過去の注文履歴を保持することで、後から確認可能
3. **データ保護**: 外部キー制約（`ON DELETE RESTRICT`）により、誤って物理削除することを防止
4. **運用の柔軟性**: 論理削除（`is_active = false`）により、ユーザーを無効化しながらデータを保持

### 実装

- 既存ユーザーの削除は`is_active = false`に設定するだけ（論理削除）
- `orders.user_id`の外部キー制約は`ON DELETE RESTRICT`に設定
- 削除時に注文データの存在をチェックし、警告ログを出力
- 承認待ちユーザーの削除（物理削除）は、注文データがない前提で実装

### 注意事項

- 物理削除が必要な場合は、まず注文データを削除してからユーザーを削除する必要がある
- ただし、通常は論理削除（`is_active = false`）で十分

---

## ユーザー削除時の承認待ちリスト除外

### 判断

**ユーザー削除時に`left_date`を今日の日付に設定し、承認待ちリストから除外する。承認待ちAPIの条件は`left_date >= 明日`とする。**

### 理由

1. **明確な分類**: 削除されたユーザーと承認待ちユーザーを明確に区別する
2. **リストの正確性**: 承認待ちリストに不要なユーザーが蓄積しないようにする
3. **即時反映**: 削除直後から正しい状態が表示されるようにする
4. **運用の簡素化**: 管理者が承認待ちユーザーを正確に把握できるようにする

### 実装

- 削除APIで`is_active = false`と`left_date = 今日の日付`を同時に設定
- 承認待ちAPIの条件を`left_date >= 明日`に変更（今日の日付を除外）
- フロントエンドで削除後に`fetchPendingUsers()`も呼び出す

### 承認待ちユーザーの定義

- **承認待ち**: `is_active = false` かつ `left_date`が未設定または未来の日付（明日以降）
- **無効なユーザー**: `is_active = false` かつ `left_date`が過去または今日の日付

---

## ダッシュボード集計でのService Role Key使用

### 判断

**ダッシュボードの集計データ取得時はService Role Keyを使用してRLSをバイパスする**

### 理由

1. **正確性**: RLSポリシーの影響で、通常のクライアントでは全ユーザーを取得できない場合がある
2. **一貫性**: 管理者が閲覧するダッシュボードでは、すべてのデータを正確に表示する必要がある
3. **権限管理**: Service Role Keyは管理者権限チェック後に使用するため、セキュリティは維持される

### 実装

- ダッシュボード（`app/admin/page.tsx`）で`supabaseAdmin`を使用
- アクティブユーザー数、承認待ちユーザー数、アクティブ業者数、アクティブメニュー数を取得

---

## 承認待ちユーザーの定義

### 判断

**承認待ちユーザーは「`is_active = false`かつ退職日が未設定または未来の日付」と定義する**

### 理由

1. **明確性**: 退職者（`left_date`が過去の日付）と承認待ちユーザーを区別する必要がある
2. **運用の正確性**: 承認待ちユーザーのみを適切に表示・管理できるようにする
3. **ユーザビリティ**: 管理者が承認待ちユーザーを正確に把握できるようにする

### 実装

- ダッシュボードと承認待ちユーザーAPIで、`is_active = false`かつ`left_date`が未設定または未来の日付でフィルタリング

---

## ユーザー管理画面の表示方法

### 判断

**ユーザー管理画面は「有効なユーザー」「無効なユーザー」「承認待ち」の3つのタブに分割して表示する**

### 理由

1. **可読性**: 退職者が多くても、有効なユーザーをすぐに確認できる
2. **運用効率**: タブ切り替えにより、必要な情報に素早くアクセスできる
3. **視認性**: 無効なユーザーをグレーアウト表示することで、状態が一目でわかる

### 実装

- 有効なユーザータブ: `is_active = true`のユーザーのみ表示
- 無効なユーザータブ: `is_active = false`かつ退職日が設定されているユーザーを表示
- 承認待ちタブ: `is_active = false`かつ退職日が未設定または未来のユーザーを表示

---

## 社員コードマスター管理画面のメニュー削除

### 判断

**管理者メニューから社員コードマスター管理画面のメニュー項目を削除する**

### 理由

1. **自動更新**: 社員コード変更機能で内部的に自動更新されるため、管理者が手動で管理する必要性が低い
2. **運用の簡素化**: 不要なメニュー項目を削除することで、管理画面を簡潔にする
3. **機能の維持**: 管理画面とAPIは残す（社員コード変更機能で内部的に使用されるため）
4. **アクセス可能性**: 直接URL（`/admin/employee-codes`）でアクセス可能なため、必要な場合はアクセス可能

### 実装

- `components/admin-nav.tsx`から「社員コードマスター」メニュー項目を削除
- 管理画面（`app/admin/employee-codes/page.tsx`）とAPIは維持

---

## 注文の締切時刻チェックの動作

### 判断

**注文作成・変更・キャンセルのすべての処理で、処理実行時点（API呼び出し時点）で締切時刻をチェックする**

### 理由

1. **セキュリティ**: クライアント側の時刻は改ざん可能なため、サーバー側の現在時刻で判定する
2. **一貫性**: すべてのユーザーが同じ基準時刻で判定される
3. **公平性**: 作業中に締切時刻を過ぎても、確定処理の時点でチェックされるため、締切時刻を過ぎた操作は実行されない
4. **予測可能性**: 処理実行時点で判定することで、システムの動作が予測可能になる

### 実装

- 注文作成（POST /api/orders）: 締切時刻を過ぎている場合は「締切時刻を過ぎています」というエラー
- 注文変更（PUT /api/orders/[id]）: 締切時刻を過ぎている場合は「締切時刻を過ぎているため、注文を変更できません」というエラー
- 注文キャンセル（PATCH /api/orders/[id]）: 締切時刻を過ぎている場合は「最終の確定処理で時間を過ぎているためキャンセルできません」というエラー

---

## 管理者による過去の注文入力・削除機能

### 判断

**管理者モードの場合のみ過去の日付に注文を作成し、注文を物理削除できるようにする**

### 理由

1. **データ修正の必要性**: 後日注文データに間違いがわかったとき、管理者が修正できるようにする必要がある
2. **会計・集計の正確性**: 注文データの間違いを修正することで、会計・集計の正確性を保証する
3. **運用の柔軟性**: 管理者が過去の注文を入力・削除できることで、運用上の柔軟性が向上する
4. **セキュリティ**: 管理者のみが操作可能にすることで、一般ユーザーによる不正な操作を防止
5. **明確な権限分離**: 管理者がユーザー画面から開く場合は通常の範囲での変更のみ許可し、管理画面から開く場合のみ過去の注文操作を許可することで、権限を明確に分離する

### 実装

- **管理者モードの定義**: `user_id`パラメータが指定されている場合のみ管理者モード（管理者権限がある場合のみ許可）
- 注文作成APIで、管理者モードの場合は過去の日付チェック、最大注文可能日数チェック、注文可能日チェック、締切時刻チェックをスキップ
- 注文削除API（`DELETE /api/orders/[id]`）を追加（管理者のみ、物理削除）
- 注文一覧画面に削除ボタンを追加
- 監査ログに削除操作を記録（`order.delete.admin`アクション）
- カレンダー画面と注文作成画面で管理者モード判定を実装

---

## 締切時刻を過ぎた注文のキャンセル制限

### 判断

**一般ユーザーは締切時刻を過ぎた注文をキャンセルできないようにする。管理者は締切時刻を過ぎた注文もキャンセル可能とする。**

### 理由

1. **データ整合性**: 締切時刻を過ぎた注文は確定済みとして扱い、一般ユーザーによるキャンセルを防止することで、データ整合性を保証する
2. **運用の柔軟性**: 管理者は運用上の柔軟性のため、締切時刻を過ぎた注文もキャンセル可能とする
3. **ユーザビリティ**: 一般ユーザーが締切時刻を過ぎた注文にキャンセルボタンを押してエラーが発生することを防止

### 実装

- 注文履歴画面で、締切時刻を過ぎた注文のキャンセルボタンを非表示
- キャンセルAPIで、一般ユーザーの場合は締切時刻を過ぎた注文をキャンセル不可
- 管理者の場合は締切時刻を過ぎた注文もキャンセル可能

---

## 管理者モード判定ロジック

### 判断

**管理者モードは`user_id`パラメータが指定されている場合のみ有効とし、管理者が管理画面から自分のカレンダーを開く場合も管理者モードで動作する**

### 理由

1. **明確な権限分離**: 管理者がユーザー画面から開く場合は通常の範囲での変更のみ許可し、管理画面から開く場合のみ過去の注文操作を許可することで、権限を明確に分離する
2. **運用の柔軟性**: 管理者が管理画面から自分のカレンダーを開く場合も管理者モードで動作することで、過去の注文操作が可能になる
3. **一貫性**: 管理者が管理画面から開く場合とユーザー画面から開く場合で動作が異なることを明確にする

### 実装

- 管理者モードの定義: `isAdminMode = isAdmin && user_id !== undefined`
- カレンダー画面で管理者モード判定を実装
- 注文作成画面で管理者モード判定を実装
- カレンダーグリッドで管理者モード判定を実装
- API側で管理者モード判定を実装
- 管理者が管理画面から自分のカレンダーを開く場合も`user_id`パラメータを指定

---

## Transaction connection (6543)のフォールバック処理

### 判断

**`DATABASE_URL`環境変数が設定されていない場合でも、通常のSupabaseクライアントを使用して動作するフォールバック処理を実装する**

### 理由

1. **柔軟性**: `DATABASE_URL`環境変数はオプション機能（パフォーマンス向上のため）であるため、設定されていない場合でも動作する必要がある
2. **ユーザビリティ**: 開発環境や本番環境で`DATABASE_URL`を設定していない場合でも、アプリケーションが正常に動作する
3. **段階的な移行**: 既存のSupabaseクライアントからTransaction connectionへの移行を段階的に行える
4. **エラー回避**: `DATABASE_URL`が設定されていない場合にエラーが発生し、カレンダーページなどが表示できない問題を回避

### 実装

- `getDatabaseUrlOptional()`関数を使用して、`DATABASE_URL`が設定されているかチェック
- `hasDatabaseUrl`変数で、設定されている場合とされていない場合で処理を分岐
- `DATABASE_URL`が設定されている場合: Transaction connection (6543)を使用（パフォーマンス向上）
- `DATABASE_URL`が設定されていない場合: 通常のSupabaseクライアントを使用（フォールバック）
- カレンダーページ（`app/(user)/calendar/page.tsx`）で実装
  - プロフィール取得処理のフォールバック
  - カレンダー・注文データ取得処理のフォールバック
  - メニューデータ取得処理のフォールバック
  - 管理者モードの判定もフォールバック処理内で正しく実行

### 注意事項

- Transaction connection (6543)を使用すると、パフォーマンスが向上しますが、必須ではありません
- `DATABASE_URL`を設定する場合は、`env.example`を参照してください
- フォールバック処理は、通常のSupabaseクライアントを使用するため、RLSが自動適用されます

---

## Next.js 16のサーバーコンポーネントからクライアントコンポーネントへのprops渡し

### 判断

**サーバーコンポーネントからクライアントコンポーネントに渡すpropsは、JSONシリアライズ可能なデータのみを使用する**

### 理由

1. **Next.jsの制限**: Next.jsでは、サーバーコンポーネントからクライアントコンポーネントに渡すpropsは、JSONシリアライズ可能である必要がある
2. **Map型の非対応**: `Map`型や`Set`型、関数などはJSONシリアライズできないため、そのまま渡すことができない
3. **実行時エラー**: シリアライズできないデータを渡すと、クライアントサイドで正しく動作しない（データが`undefined`になる）
4. **ビルド時検出不可**: ビルド時には検出されず、実行時エラーとして発生するため、デバッグが困難

### 実装

- `Map`型を通常のオブジェクト（`Record<string, T>`）に変換
- クライアントコンポーネントで`Map`型とオブジェクト型の両方に対応
- オブジェクトアクセス時のエラーハンドリングを追加
- デバッグログを追加して、本番環境での問題を特定しやすくする

### 注意事項

- **シリアライズ可能な型**: `string`、`number`、`boolean`、`null`、`undefined`、配列、通常のオブジェクト（プレーンオブジェクト）
- **シリアライズ不可な型**: `Map`、`Set`、`Date`、`Function`、`RegExp`など
- **Date型の扱い**: `Date`型も渡せないため、文字列（ISO形式など）に変換して渡す必要がある

---

## audit_logs.actor_id 外部キー制約の ON DELETE SET NULL 設定

### 判断

**`audit_logs.actor_id -> auth.users.id` の外部キー制約を `ON DELETE SET NULL` に設定する**

### 理由

1. **監査ログの保持**: ユーザーを削除しても監査ログは保持する必要がある（監査性のため）
2. **データ保護**: 監査ログは削除してはいけない重要なデータ
3. **運用の柔軟性**: Authユーザーを削除できるようにする（誤登録などへの対応）
4. **参照整合性**: `actor_id` を NULL にすることで、参照整合性を保ちながらユーザー削除を可能にする

### 実装

- `audit_logs.actor_id` カラムを NULL 許可に設定
- 外部キー制約を `ON DELETE SET NULL` に変更
- ユーザー削除時、`actor_id` は自動的に NULL になるが、監査ログの行自体は保持される

### 注意事項

- 監査ログの行自体は削除されない（`ON DELETE SET NULL` のため）
- ユーザー削除後、`actor_id` が NULL になった監査ログが存在する
- 監査ログ閲覧画面では、`actor_id` が NULL の場合は適切に表示する必要がある（既存実装で対応済み）

---

## まとめ

これらの判断は、以下の原則に基づいています：

1. **データ整合性**: データベースレベルで整合性を保証
2. **セキュリティ**: 最小権限の原則と RLS によるアクセス制御
3. **監査性**: すべての重要な操作を記録
4. **柔軟性**: 将来的な変更に対応できる設計
5. **予測可能性**: システムの動作が予測可能で一貫性がある
6. **保守性**: 設定の一元管理により、保守が容易になる
7. **ユーザビリティ**: ユーザーが使いやすい機能を提供
8. **運用の簡素化**: 手動操作を減らし、自動化により運用を簡素化
9. **データ保護**: 会計・集計データを保護するため、重要なデータは削除しない
10. **表示の正確性**: 管理者向け画面では、正確なデータを表示するために適切な権限でアクセスする
11. **明確な分類**: ユーザーの状態を明確に分類し、適切なリストに表示する
12. **UIの簡潔性**: 不要なメニュー項目を削除することで、管理画面を簡潔にする
13. **処理実行時点での判定**: すべての重要なチェックは処理実行時点で行い、公平性と予測可能性を保証する
14. **運用の柔軟性**: 管理者が過去の注文を入力・削除できることで、データ修正の柔軟性を確保
15. **データ修正の必要性**: 後日注文データに間違いがわかったとき、管理者が修正できるようにする
16. **監査ログの保持**: ユーザー削除時も監査ログを保持し、監査性を確保する